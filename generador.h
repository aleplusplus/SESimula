// Generador.h: Definicion e Implementacion de la Clase Generador para generar numeros aleatorios y distribuciones

#ifndef GENERADOR_H
#define GENERADOR_H

//#include <QtGlobal>

#include <QString>

#include <fstream>
#include <math.h>
#include <limits.h>
#include <unistd.h>

//#include <stl>

// Constants for Tausworthe random bit generator
// Ref: Tausworthe, Robert C., "Random Numbers Generated by Linear Recurrence
//      ModuloTwo," Mathematics of Computation, vol. 19, pp. 201-209, 1965.

// Coefficients that define a primitive polynomial (mod 2)
// Ref: Watson, E. J., "Primitive Polynomials (Mod 2),"
//      Mathematicsof Computation, vol. 16, pp. 368-369, 1962.


class Generador {
    // operadores amigos
    // sobrecargando operador igual
    friend bool operator==( const Generador& p, const Generador& q )
	{
        bool equal = ( p._semilla == q._semilla ) && ( p._next == q._next );
		for ( int i = 0; i < p._NTAB; i++ )
			equal = equal && ( p._table[ i ] == q._table[ i ] );
		return equal;
	}

    // sobrecargando operador distinto
    friend bool operator!=( const Generador& p, const Generador& q )
	{
		return !( p == q );
	}

//	 overloaded stream operator
//	friend istream& operator>>( istream& is, Generador& rv )
//	{
//		cout << "Enter a random number semilla "
//		<< "(between 1 and " << LONG_MAX - 1 << ", inclusive): " << endl;
//		is >> rv._semilla;
//		Q_ASSERT( rv._semilla != 0 && rv._semilla != LONG_MAX );
//		rv._semillaTable();
//		return is;
//	}

public:

    //-----Constrcutores por Defecto
//    Generador( long semilla ) // constructor to set the semilla
//	{
//        Q_ASSERT( semilla != 0 && semilla != LONG_MAX );
//        _semilla = semilla;
//        _flag = 0;
//        _semillaTable();
//        _semilla2 = _semilla | 1; // for tausworthe random bit generation
//	}
    Generador( void ) // default constructor uses process id to set the semilla
	{
        _semilla = long( getpid() );
        _flag = 0;
        _semillaTable();
        _semilla2 = _semilla | 1; // for tausworthe random bit generation
	}
	
    ~Generador( void ){} // default destructor
	
    Generador( const Generador& r ) // copy constructor (copies current state)
	{
        _semilla =r._semilla;
        _semilla2 = r._semilla2;
		// copy the current state of the shuffle table
		_next = r._next;
		for ( int i = 0; i < _NTAB; i++ ) 
			_table[ i ] = r._table[ i ];
	}
	
    Generador& operator=( const Generador& r ) // overloaded assignment
	{
		if ( *this == r ) return *this;
        _semilla =r._semilla;
        _semilla2 = r._semilla2;
		// copy the current state of the shuffle table
		_next = r._next;
		for ( int i = 0; i < _NTAB; i++ ) 
			_table[ i ] = r._table[ i ];
		return *this;
	}

    //-----Contructores de Generadores Expecificos

    // Generador Congruencial Mixto si A != 0 y C != 0, Multiplicativo C == 0 y Aditivo A == 0
    Generador(long semilla, long A, long C, long M){
        _semilla = semilla;
        __A = A;
        __C = C;
        __M = M;
        _flag = 1;
        _contador = 0;
        _semillaTable();
    }

    //-----Otros

    // Generador cuadratico
    Generador(double semillacuadratica){
        _semilla = semillacuadratica;
        _flag = 2;
        _contador = 0;
        _semillaTable();
    }

    // Generador Multiplicativo
    Generador( double semillaM1, double semillaM2 ){
        _semilla = semillaM1;
        __A = semillaM2;
        _flag = 3;
        _contador = 0;
        _semillaTable();
    }


    // Funciones Utilies

    void reset( long semilla ) // reset the semilla explicitly
    {
        Q_ASSERT( semilla != 0 && semilla != LONG_MAX );
        _semilla = semilla;
        _flag = 1;
        _semillaTable();
        _semilla2 = _semilla | 1; // so that all bits cannot be zero
    }

    void reset( void ) // reset semilla from current process id
    {
        _semilla = long( getpid() );
        _flag = 1;
        _semillaTable();
        _semilla2 = _semilla | 1; // so that all bits cannot be zero
    }

    // Distribuciones Continuas

    double arcsine( double xMin = 0., double xMax = 1. ) // Arc Sine
    {
        double q = sin( M_PI_2 * _u() );
        return xMin + ( xMax - xMin ) * q * q;
    }

    double beta( double v, double w, // Beta
                 double xMin = 0., double xMax = 1. ) // (v > 0. and w > 0.)
    {
        if ( v < w )
            return xMax - ( xMax - xMin ) * beta( w, v );
        double y1 = gamma( 0., 1., v );
        double y2 = gamma( 0., 1., w );
        return xMin + ( xMax - xMin ) * y1 / ( y1 + y2 );
    }

    double cauchy( double a = 0., double b = 1. ) // Cauchy (or Lorentz)
    {
    // a is the location parameter and b is the scale parameter
    // b is the half width at half maximum (HWHM) and variance doesnt exist
        Q_ASSERT( b > 0. );
        return a + b * tan( M_PI * uniform( -0.5, 0.5 ) );
    }

    double chiSquare( int df ) // Chi-Square
    {
        Q_ASSERT( df >= 1 );
        return gamma( 0., 2., 0.5 * double( df ) );
    }

    double cosine( double xMin = 0., double xMax = 1. ) // Cosine
    {
        Q_ASSERT( xMin < xMax );
        double a = 0.5 * ( xMin + xMax ); // location parameter
        double b = ( xMax - xMin ) / M_PI; // scale parameter
        return a + b * asin( uniform( -1., 1. ) );
    }

    double doubleLog( double xMin = -1., double xMax = 1. ) // Double Log
    {
        Q_ASSERT( xMin < xMax );
        double a = 0.5 * ( xMin + xMax ); // location parameter
        double b = 0.5 * ( xMax - xMin ); // scale parameter
        if ( bernoulli( 0.5 ) )
            return a + b * _u() * _u();
        else
            return a - b * _u() * _u();
    }

    double erlang( double b, int c ) // Erlang (b > 0. and c >= 1)
    {
        Q_ASSERT( b > 0. && c >= 1 );
        double prod = 1.;
        for ( int i = 0; i < c; i++ )
            prod *= _u();
        return -b * log( prod );
    }

    double exponential( double a = 0., double c = 1. ) // Exponential
    { //location a, shape c
        Q_ASSERT( c > 0.0 );
        return a - c * log( _u() );
    }

    double extremeValue( double a = 0., double c = 1. ) // Extreme Value
    { //location a, shape c
        Q_ASSERT( c > 0. );
        return a + c * log( -log( _u() ) );
    }

    double fRatio( int v, int w ) // F Ratio (v and w >= 1)
    {
        Q_ASSERT( v >= 1 && w >= 1 );
        return ( chiSquare( v ) / v ) / ( chiSquare( w ) / w );
    }

    double gamma( double a, double b, double c ) // Gamma
    { //location a, scale b, shape c
        Q_ASSERT( b > 0. && c > 0. );
        const double A = 1. / sqrt( 2. * c - 1. );
        const double B = c - log( 4. );
        const double Q = c + 1. / A;
        const double T = 4.5;
        const double D = 1. + log( T );
        const double C = 1. + c / M_E;
        if ( c < 1. ) {
            while ( true ) {
                double p = C * _u();
                if ( p > 1. ) {
                    double y = -log( ( C - p ) / c );
                    if ( _u() <= pow( y, c - 1. ) )
                        return a + b * y;
                }
                else {
                    double y = pow( p, 1. / c );
                    if ( _u() <= exp( -y ) )
                        return a + b * y;
                }
            }
        }
        else if ( c == 1.0 ) return exponential( a, b );
        else {
            while ( true ) {
                double p1 = _u();
                double p2 = _u();
                double v = A * log( p1 / ( 1. - p1 ) );
                double y = c * exp( v );
                double z = p1 * p1 * p2;
                double w = B + Q * v - y;
                if ( w + D - T * z >= 0. || w >= log( z ) )
                    return a + b * y;
            }
        }
    }

    double laplace( double a = 0., double b = 1. ) // Laplace
    { //(or double exponential)
        Q_ASSERT( b > 0. );
        // composition method
        if ( bernoulli( 0.5 ) )
            return a + b * log( _u() );
        else
            return a - b * log( _u() );
    }

    double logarithmic( double xMin = 0., double xMax = 1. ) // Logarithmic
    {
        Q_ASSERT( xMin < xMax );
        double a = xMin; // location parameter
        double b = xMax - xMin; // scale parameter
        // use convolution formula for product of two IID uniform variates
        return a + b * _u() * _u();
    }

    double logistic( double a = 0., double c = 1. ) // Logistic
    {
        Q_ASSERT( c > 0. );
        return a - c * log( 1. / _u() - 1. );
    }

    double lognormal( double a, double mu, double sigma ) // Lognormal
    {
        return a + exp( normal( mu, sigma ) );
    }

    double normal( double mu = 0., double sigma = 1. ) // Normal
    {
        Q_ASSERT( sigma > 0. );
        static bool f = true;
        static double p, p1, p2;
        double q;
        if ( f ) {
            do {
                p1 = uniform( -1., 1. );
                p2 = uniform( -1., 1. );
                p=p1*p1+p2*p2;
            }
            while ( p >= 1. );
            q=p1;
        }
        else
            q=p2;
        f=!f;
        return mu + sigma * q * sqrt( -2. * log( p ) / p );
    }

    double parabolic( double xMin = 0., double xMax = 1. ) // Parabolic
    {
        Q_ASSERT( xMin < xMax );
        double a =0.5 * ( xMin + xMax ); // location parameter
        double yMax = _parabola( a, xMin, xMax ); // maximum function range
        return userSpecified( _parabola, xMin, xMax, 0., yMax );
    }

    double pareto( double c ) // Pareto
    { //shape c
        Q_ASSERT( c > 0. );
        return pow( _u(), -1. / c );
    }

    double pearson5( double b, double c ) // Pearson Type 5
    { //scale b, shape c
        Q_ASSERT( b > 0. && c > 0. );
        return 1. / gamma( 0., 1. / b, c );
    }

    double pearson6( double b, double v, double w ) // Pearson Type 6
    { //scale b, shape v & w
        Q_ASSERT( b > 0. && v > 0. && w > 0. );
        return gamma( 0., b, v ) / gamma( 0., b, w );
    }

    double power( double c ) // Power
    { //shape c
        Q_ASSERT( c > 0. );
        return pow( _u(), 1. / c );
    }

    double rayleigh( double a, double b ) // Rayleigh
    { //location a, scale b
        Q_ASSERT( b > 0. );
        return a + b * sqrt( -log( _u() ) );
    }

    double studentT( int df ) // Students T
    { //degres of freedom df
        Q_ASSERT( df >= 1 );
        return normal() / sqrt( chiSquare( df ) / df );
    }

    double triangular( double xMin = 0., // Triangular
                       double xMax = 1., // with default interval [0,1)
                       double c =0.5 )   // and default mode 0.5
    {
        Q_ASSERT( xMin < xMax && xMin <= c && c <= xMax );
        double p = _u(), q = 1. - p;
        if ( p <= ( c - xMin ) / ( xMax - xMin ) )
            return xMin + sqrt( ( xMax - xMin ) * ( c - xMin ) * p );
        else
            return xMax - sqrt( ( xMax - xMin ) * ( xMax - c ) * q );
    }

    double uniform( double xMin = 0., double xMax = 1. ) // Uniform
    { //on[xMin,xMax)
        Q_ASSERT( xMin < xMax );
        return xMin + ( xMax - xMin ) * _u();
    }

    double userSpecified( // User-Specified Distribution
                        double( *usf )( // pointer to user-specified function
                        double,  //x
                        double,  //xMin
                        double ), // xMax
                        double xMin, double xMax, // function domain
                        double yMin, double yMax ) // function range
    {
        Q_ASSERT( xMin < xMax && yMin < yMax );
        double x, y, areaMax = ( xMax - xMin ) * ( yMax - yMin );
        // acceptance-rejection method
        do {
            x=uniform( 0.0, areaMax ) / ( yMax - yMin ) + xMin;
            y=uniform( yMin, yMax );
        }
        while ( y > usf( x, xMin, xMax ) );
        return x;
    }

    double weibull( double a, double b, double c ) // Weibull
    { //location a, scale b,
        Q_ASSERT( b > 0. && c > 0. ); // shape c
        return a + b * pow( -log( _u() ), 1. / c );
    }

    // Distribuciones Discretas

    bool bernoulli( double p = 0.5 ) // Bernoulli Trial
    {
        Q_ASSERT( 0. <= p && p <= 1. );
        return _u() < p;
    }
    int binomial( int n, double p ) // Binomial
    {
        Q_ASSERT( n >= 1 && 0. <= p && p <= 1. );
        int sum = 0;
        for ( int i = 0; i < n; i++ )
            sum += bernoulli( p );
        return sum;
    }

    int geometric( double p ) // Geometric
    {
        Q_ASSERT( 0. < p && p < 1. );
        return int( log( _u() ) / log( 1. - p ) );
    }
    int hypergeometric( int n, int N, int K ) // Hypergeometric
    { //trials n, size N,
        Q_ASSERT( 0 <= n && n <= N && N >= 1 && K >= 0 ); // successes K
        int count = 0;
        for ( int i = 0; i < n; i++, N-- ) {
            double p = double( K ) / double( N );
            if ( bernoulli( p ) ) { count++; K--; }
        }
        return count;
    }

    void multinomial( int n,  		//Multinomial
                      double p[], 	// trials n, probability vector p,
                      int  count[], // success vector count,
                      int  m) 		//number of disjoint events m
    {
        Q_ASSERT( m >= 2 ); // at least 2 events
        double sum = 0.;
        for ( int bin = 0; bin < m; bin++ ) sum += p[ bin ]; // probabilities
        Q_ASSERT( sum == 1. ); // must sum to 1
        for ( int bin = 0; bin < m; bin++ ) count[ bin ] = 0; // initialize
        // generate n uniform variates in the interval [0,1) and bin the results
        for ( int i = 0; i < n; i++ ) {
            double lower = 0., upper = 0., u = _u();
            for ( int bin = 0; bin < m; bin++ ) {
            // locate subinterval, which is of length p[ bin ],
            // that contains the variate and increment the corresponding counter
                lower = upper;
                upper += p[ bin ];
                if ( lower <= u && u < upper ) { count[ bin ]++; break; }
            }
        }
    }

    int negativeBinomial( int s, double p ) // Negative Binomial
    { //successes s, probability p
        Q_ASSERT( s >= 1 && 0. < p && p < 1. );
        int sum = 0;
        for ( int i = 0; i < s; i++ )
            sum += geometric( p );
        return sum;
    }

    int pascal( int s, double p ) // Pascal
    { //successes s, probability p
        return negativeBinomial( s, p ) + s;
    }

    int poisson( double mu ) // Poisson
    {
        Q_ASSERT ( mu > 0. );
        double a = exp( -mu );
        double b = 1.;
        int i;
        for ( i = 0; b >= a; i++ )
            b *= _u();
        return i - 1;
    }

    int uniformDiscrete( int i, int j ) // Uniform Discrete
    { //inclusive i to j
        Q_ASSERT( i < j );
        return i + int( ( j - i + 1 ) * _u() );
    }

private:
    static const long _A  =0x10ff5;  //69621
    static const long _C  =0;  //0 (OJO)
    static const long _M  =0x7fffffff; // 2147483647 (Mersenne prime 2^31-1)
    static const long _Q  =0x787d;  //30845
    static const long _R  =0x5d5e;  //23902
    static const double _F =1./_M;
	static const short _NTAB = 32; // arbitrary length of shuffle table
    static const long _DIV =1+(_M-1)/_NTAB;
    long _table[_NTAB ]; //tabla de semillas
    long _next; // semilla en uso en indice de la tabla
    long _semilla; // current random number semilla
    long __A;
    long __C;
    long __M;
    unsigned  _semilla2; // semilla for tausworthe random bit
    int _flag; // bandera para los distintos generadores
    short _contador; // indice de la tabla de semillas
	
    void _semillaTable() // semillas the shuffle table
	{
        switch ( _flag ) {
        case 1: // Caso de Congruencial
            _table[ 0 ] = _semilla;
            for ( int i = 1; i < _NTAB; i++ ) { //
               _semilla = (_semilla * __A + __C) % __M;
               _table[ i ] = _semilla;
            }
            break;
        case 2: // Caso Cuadratico
            _table[ 0 ] = _semilla;
            for ( int i = 1; i < _NTAB; i++ ) { //
               _semilla = _semilla * _semilla;
               _table[ i ] = _semilla;
            }
            break;
        case 3: // Caso Multiplicativo
            _table[ 0 ] = _semilla;
            _table[ 1 ] = __A;
            for ( int i = 2; i < _NTAB; i++ ) { //
               _semilla = _semilla * _table[ i-1 ];;
               _table[ i ] = _semilla;
            }
            break;
        default: //Caso por defecto
            for ( int i = _NTAB + 7; i >= 0; i-- ) { // first perform 8 warm-ups
                long k = _semilla / _Q; // semilla = ( A * semilla ) % M
                _semilla = _A * ( _semilla - k * _Q ) - k * _R; // without overflow by
                if ( _semilla < 0 ) _semilla += _M; // Schrages method
                if ( i < _NTAB ) _table[ i ] = _semilla; // store semillas into table
            }
            _next = _table[ 0 ]; // used as index next time
            break;
        }
	}
	
    double _u() // uniform rng
	{
        double u;
        switch ( _flag ) {
        case 1:
            if(_contador == 31){
                _next = _table[ _contador ];
                _semilla = (_semilla * __A + __C) % __M;
                _table[_contador] = _semilla;
                _contador = 0;
            }
            else{
                _next = _table[ _contador ];
                _semilla = (_semilla * __A + __C) % __M;
                _table[_contador] = _semilla;
                _contador++;
            }
            u = _next / pow(10,QString("%1").arg(_next).size()); //OOOOOOOOJJJJOOOOOOOO
            break;
        case 2:
            if(_contador == 31){
                _next = _table[ _contador ];
                _semilla = _semilla * _semilla;
                _table[_contador] = _semilla;
                _contador = 0;
            }
            else{
                _next = _table[ _contador ];
                _semilla = _semilla * _semilla;
                _table[_contador] = _semilla;
                _contador++;
            }
            u = _next / pow(10,QString("%1").arg(_next).size()); //OOOOOOOOJJJJOOOOOOOO
            break;
        case 3:
            if(_contador == 31){
                _next = _table[ _contador ];
                _semilla = _semilla * _table[ _contador - 1 ];
                _table[_contador] = _semilla;
                _contador = 0;
            }
            else{
                _next = _table[ _contador ];
                _semilla = (_semilla * __A + __C) % __M;
                _table[_contador] = _semilla;
                _contador++;
            }
            u = _next / pow(10,QString("%1").arg(_next).size()); //OOOOOOOOJJJJOOOOOOOO
            break;
        default:
            long k = _semilla / _Q; // semilla = ( A*semilla ) % M
            _semilla = _A * ( _semilla - k * _Q ) - k * _R; // without overflow by
            if ( _semilla < 0 )
                _semilla += _M; // Schrages method
            int index = _next / _DIV; // Bays-Durham shuffle
            _next = _table[ index ]; // semilla used for next time
            _table[ index ] = _semilla; // replace with new semilla
            u =_next * _F; // scale value within [0,1);
        }
        return u;
	}

	static double _parabola( double x, double xMin, double xMax ) // parabola
	{
		if ( x < xMin || x > xMax ) 
			return 0.0;
		double a =0.5 * ( xMin + xMax ); // location parameter
		double b =0.5 * ( xMax - xMin ); // scale parameter
		double yMax = 0.75 / b;
		return yMax * ( 1. - ( x - a ) * ( x - a ) / ( b * b ) );
	}
};
#endif
